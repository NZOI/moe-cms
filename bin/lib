# The Evaluator -- Shell Function Library
# (c) 2001--2007 Martin Mares <mj@ucw.cz>

# General settings
shopt -s dotglob

# Logging functions.
# File handles used: fd1=log, fd2=progress

function log-init
{
	exec >>$TDIR/log
	HAVE_LOG=1
}

function pstart
{
	echo >&2 -n "$@"
}

function pcont
{
	echo >&2 -n "$@"
}

function pend
{
	echo >&2 "$@"
}

function die
{
	# Report an internal error
	echo >&2 "$@"
	[ -n "$HAVE_LOG" ] && echo "Fatal error: $@"
	exit 2
}

function fatal
{
	# Report a fatal error in the program being tested
	echo >&2 "$@"
	[ -n "$HAVE_LOG" ] && echo "Fatal error: $@"
	exit 1
}

function try-ln
{
	ln $1 $2 2>/dev/null || cp $1 $2
}

# Sandbox subroutines

function box-init
{
	pstart "Preparing sandbox... "
	if [ -z "$TEST_USER" -o "$TEST_USER" == $EVAL_USER ] ; then
		pcont "running locally (INSECURE), "
		TEST_USER=$EVAL_USER
		BOXDIR=box
		BOXCMD=bin/box
		mkdir -p box
	else
		pcont "used account $TEST_USER, "
		BOXDIR=$MO_ROOT/eval/$TEST_USER
		BOXCMD=bin/box-$TEST_USER
	fi
	[ -d $BOXDIR -a -f $BOXCMD ] || die "Sandbox set up incorrectly"
	BOXCMD="$BOXCMD -c$BOXDIR"
	echo "Sandbox directory: $BOXDIR"
	echo "Sandbox command: $BOXCMD"
	box-clean
	pend "OK"
}

function box-clean
{
	[ -n "$BOXCMD" ] || die "box-init not called"
	rm -rf $BOXDIR/*
}

# Initialization of testing directories

function dir-init
{
	pstart "Initializing... "
	HDIR=.
	PDIR=problems/$PROBLEM
	SDIR=solutions/$CONTESTANT/$PROBLEM
	TDIR=testing/$CONTESTANT/$PROBLEM
	TMPDIR=tmp
	[ -d $PDIR ] || die "Problem $PROBLEM not known"
	[ -d $SDIR ] || fatal "Solution of $PROBLEM not found"
	mkdir -p $TDIR $TMPDIR
	rm -rf $TDIR $TMPDIR
	mkdir -p $TDIR $TMPDIR
	cat >$TDIR/log <<EOF
Testing solution of $PROBLEM by $CONTESTANT
Test started at `date`
Contestant's solution directory: $SDIR
Problem directory: $PDIR
Testing directory: $TDIR
EOF
	pend "OK"
}

# Locate source file.
# If no parameter is given, locate it in SDIR and return name as SRCN and extension as SRCEXT
# Or a file name can be given and then SDIR, SRCN and SRCEXT are set.
# Beware, SDIR and SRCN can contain spaces and other strange user-supplied characters.

function locate-source
{
	pstart "Finding source... "
	local SBASE
	if [ -n "$1" ] ; then
		SDIR=`dirname "$1"`
		local S=`basename "$1"`
		SBASE=$(echo "$S" | sed 's/\.\([^.]\+\)//')
		SRCEXT=$(echo "$S" | sed '/\./!d; s/.*\.\([^.]\+\)/\1/')
		if [ -n "$SRCEXT" ] ; then
			# Full name given, so just check the extension and existence
			SRCN="$S"
			[ -f "$SDIR/$SRCN" ] || die "Cannot find source file $SDIR/$SRCN"
			SRCEXT_OK=
			for a in $EXTENSIONS ; do
				if [ $a == $SRCEXT ] ; then
					pend $SDIR/$SRCN
					echo "Explicitly set source file: $SDIR/$SRCN"
					return 0
				fi
			done
			die "Unknown extension .$SRCEXT"
		fi
	else
		SBASE=$PROBLEM
	fi
	for a in $EXTENSIONS ; do
		if [ -f "$SDIR/$SBASE.$a" ] ; then
			[ -z "$SRCN" ] || die "Multiple source files found: $SDIR/$PROBLEM.$a and $SDIR/$SRCN. Please fix."
			SRCN="$SBASE.$a"
			SRCEXT=$a
		fi
	done
	[ -n "$SRCN" ] || fatal "NOT FOUND"
	pend $SRCN
	echo "Found source file: $SDIR/$SRCN"
}

# Compilation (compile SDIR/SRCN with PDIR/COMP_EXTRAS to EXE=TDIR/PROBLEM)

function compile
{
	pstart "Compiling... "
	# Beware, the original SRCN can be a strange user-supplied name
	SRC=$PROBLEM.$SRCEXT
	cp "$SDIR/$SRCN" $TDIR/$SRC
	if [ -n "$COMP_EXTRAS" ] ; then
		echo "Extras: $COMP_EXTRAS"
		for a in $COMP_EXTRAS ; do cp $PDIR/$a $TDIR/ ; done
	fi
	box-clean
	for a in $SRC $COMP_EXTRAS ; do cp $TDIR/$a $BOXDIR/ ; done
	EXE=$PROBLEM
	CCMD=COMP_$SRCEXT
	CCMD=`eval echo ${!CCMD}`
	COMP_SANDBOX_OPTS=`eval echo $COMP_SANDBOX_OPTS`
	echo "Compiler command: $CCMD"
	echo "Compiler sandbox options: $COMP_SANDBOX_OPTS"
	eval $COMP_SANDBOX_INIT

	echo "Compiler input files:"
	ls -Al $BOXDIR
	echo "Compiler output:"
	if ! $BOXCMD $COMP_SANDBOX_OPTS -- $CCMD 2>$TDIR/compile.out ; then
		COMPILE_MSG="`cat $TDIR/compile.out`"
		pend "FAILED: $COMPILE_MSG"
		echo "$COMPILE_MSG"
		return 1
	fi
	cat $TDIR/compile.out
	rm $TDIR/compile.out
	echo "Compiler output files:"
	ls -Al $BOXDIR
	if [ ! -f $BOXDIR/$PROBLEM ] ; then
		pend "FAILED: Missing executable file"
		echo "Missing executable file"
		return 1
	fi
	EXE=$TDIR/$PROBLEM
	cp -a $BOXDIR/$PROBLEM $EXE
	echo "Compiled OK, result copied to $EXE"
	pend "OK"
}

# Running of test program according to current task type (returns exit code and TEST_MSG)

function test-run
{
	test-run-$TASK_TYPE
}

function test-result
{
	P=$1
	M=$2
	if [ -s $TDIR/$TEST.pts ] ; then
		P=`cat $TDIR/$TEST.pts`
		rm $TDIR/$TEST.pts
	fi
	echo "Verdict: $M"
	echo "Points: $P"
	test-verdict $P "$M"
}

function test-prolog
{
	pcont "<init> "
	box-clean
	echo "Executable file: $TDIR/$PROBLEM"
	if [ ! -x $TDIR/$PROBLEM ] ; then
		test-result 0 "Compile error."
	fi
	cp $TDIR/$PROBLEM $BOXDIR/
	BOX_EXTRAS=
	IN_TYPE=${IN_TYPE:-$IO_TYPE}
	OUT_TYPE=${OUT_TYPE:-$IO_TYPE}
	case $IN_TYPE in
		file)	echo "Input file: $PROBLEM.in (from $PDIR/$TEST.in)"
			try-ln $PDIR/$TEST.in $TDIR/$TEST.in
			cp $PDIR/$TEST.in $BOXDIR/$PROBLEM.in
			[ $TASK_TYPE == interactive ] || BOX_EXTRAS="$BOX_EXTRAS -i/dev/null"
			;;
		stdio)	echo "Input file: <stdin> (from $PDIR/$TEST.in)"
			try-ln $PDIR/$TEST.in $TDIR/$TEST.in
			cp $PDIR/$TEST.in $BOXDIR/.stdin
			BOX_EXTRAS="$BOX_EXTRAS -i.stdin"
			;;
		none)	echo "Input file: <none>"
			;;
		*)	die "Unknown IN_TYPE $IN_TYPE"
			;;
	esac
	if [ -n "$EV_PEDANT" -a $IN_TYPE != none ] ; then
		pcont "<pedant> "
		bin/pedant <$TDIR/$TEST.in | tr '\n' ' ' >&2
	fi
	case $OUT_TYPE in
		file)	echo "Output file: $PROBLEM.out"
			[ $TASK_TYPE == interactive ] || BOX_EXTRAS="$BOX_EXTRAS -o/dev/null"
			;;
		stdio)	echo "Output file: <stdout>"
			BOX_EXTRAS="$BOX_EXTRAS -o.stdout"
			;;
		none)	echo "Output file: <none>"
			;;
		*)	die "Unknown OUT_TYPE $OUT_TYPE"
			;;
	esac
	echo "Timeout: $TIME_LIMIT s"
	echo "Memory: $MEM_LIMIT KB"
	eval $SANDBOX_INIT
	echo "Sandbox contents before start:"
	ls -Al $BOXDIR
}

function test-epilog
{
	echo "Sandbox contents after exit:"
	ls -Al $BOXDIR
	case ${OUT_TYPE:-$IO_TYPE} in
		file)	[ -f $BOXDIR/$PROBLEM.out ] || test-result 0 "No output file."
			cp $BOXDIR/$PROBLEM.out $TDIR/$TEST.out
			;;
		stdio)	[ -f $BOXDIR/.stdout ] || test-result 0 "No output file."
			cp $BOXDIR/.stdout $TDIR/$TEST.out
			;;
	esac
}

# Running of test program with file input/output

function test-run-file
{
	test-prolog
	pcont "<run> "
	BOXOPTS="`eval echo $TEST_SANDBOX_OPTS`$BOX_EXTRAS"
	echo "Sandbox options: $BOXOPTS"
	if ! $BOXCMD $BOXOPTS -- ./$PROBLEM 2>$TMPDIR/exec.out ; then
		cat $TMPDIR/exec.out
		MSG=`tail -1 $TMPDIR/exec.out`
		test-result 0 "$MSG"
	fi
	cat $TMPDIR/exec.out
	test-epilog
}

# Running of interactive test programs

function test-run-interactive
{
	test-prolog
	pcont "<run> "
	BOXOPTS="`eval echo $TEST_SANDBOX_OPTS`$BOX_EXTRAS"
	echo "Sandbox options: $BOXOPTS"
	ICCMD=`eval echo $IA_CHECK`
	echo "Interactive checker: $ICCMD"
	if ! $HDIR/bin/iwrapper $BOXCMD $BOXOPTS -- ./$PROBLEM @@ $ICCMD 2>$TMPDIR/exec.out ; then
		cat $TMPDIR/exec.out
		MSG="`head -1 $TMPDIR/exec.out`"
		test-result 0 "$MSG"
	fi
	cat $TMPDIR/exec.out
	test-epilog
}

# "Running" of open-data problems

function test-run-open-data
{
	[ -f $SDIR/$TEST.out ] || test-result 0 "No solution."
	ln $SDIR/$TEST.out $TDIR/$TEST.out
}

# Syntax checks

function syntax-check
{
	[ -n "$SYNTAX_CHECK" ] || return 0
	[ -z "$EV_NOCHECK" ] || return 0
	pcont "<syntax> "
	SCHECK=`eval echo $SYNTAX_CHECK`
	echo "Syntax check command: $SCHECK"
	if ! eval $SCHECK 2>$TMPDIR/exec.out ; then
		cat $TMPDIR/exec.out
		MSG=`tail -1 $TMPDIR/exec.out`
		if [ -z "$MSG" ] ; then MSG="Wrong syntax." ; fi
		test-result 0 "$MSG"
	fi
	cat $TMPDIR/exec.out
}

# Output checks

function output-check
{
	MSG=
	if [ -n "$OUTPUT_CHECK" -a "$OUT_TYPE" != none -a -z "$EV_NOCHECK" ] ; then
		pcont "<check> "
		[ -f $PDIR/$TEST.out ] && ln $PDIR/$TEST.out $TDIR/$TEST.ok
		OCHECK=`eval echo $OUTPUT_CHECK`
		echo "Output check command: $OCHECK"
		if ! eval $OCHECK 2>$TMPDIR/exec.out ; then
			cat $TMPDIR/exec.out
			MSG=`tail -1 $TMPDIR/exec.out`
			if [ -z "$MSG" ] ; then MSG="Wrong answer." ; fi
			test-result 0 "$MSG"
		fi
		cat $TMPDIR/exec.out
		MSG=`tail -1 $TMPDIR/exec.out`
	fi
	if [ -z "$MSG" ] ; then MSG="OK" ; fi
	test-result $POINTS_PER_TEST "$MSG"
}

# Setup of public commands

function public-setup
{
	HDIR=$MO_ROOT
	PDIR=$MO_ROOT/problems/$PROBLEM
	SDIR=.
	TDIR=~/.test
	TMPDIR=~/.test
	[ -d $PDIR ] || die "Unknown problem $PROBLEM"

	pstart "Initializing... "
	mkdir -p $TDIR
	rm -rf $TDIR/*
	BOXDIR=~/.box
	mkdir -p $BOXDIR
	rm -rf $BOXDIR/*
	BOXCMD="$MO_ROOT/bin/box -c$BOXDIR"
	exec >check-log
	pend "OK  (see 'check-log' for details)"
}

# Locate output of open data problem, test case TEST
# Beware, SDIR and SRCN can contain spaces and other strange user-supplied characters.

function open-locate
{
	[ -f $PDIR/$TEST.in ] || die "Unknown test $TEST"
	if [ -n "$1" ] ; then
		SDIR=`dirname "$1"`
		SRCN=`basename "$1"`
	else
		SRCN=$SDIR/$PROBLEM$TEST.out
	fi
	[ -f "$SDIR/$SRCN" ] || fatal "Output file $SRCN not found"
}
